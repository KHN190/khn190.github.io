I"Gø<h2 id="lets-create-a-marble-shader-in-unity">Let‚Äôs Create a Marble Shader in Unity!</h2>

<p>Back sometime, when I wandered in the cyber space I found a post about <a href="https://80.lv/articles/building-intricate-ice-shaders/">creating intricate ice in Unity</a>, and I immediately fell in love with the visual patterns. There is an incredibly beautiful image for you to have a feel:</p>

<p><img src="./assets/img/ice_shader.png" alt="" /></p>

<p>However when I bought the asset to see how it works, I was slightly unsatisfied because most of the patterns are baked in textures. The ices are not actually usable for arbitrary objects except for plane. And they are not transparent. I clearly want a toy with similar breath but has the following traits:</p>

<ol>
  <li>it can reflect lights</li>
  <li>it can refract other objects through it</li>
  <li>it has to be transparent (by axiom 2, right?)</li>
</ol>

<p>And after some research, I had this as my result - which is also the same you will have after the tutorial:</p>

<p><img src="./assets/img/marble.gif" alt="" /></p>

<h3 id="what-do-i-need-to-know-in-advance">What do I need to know in advance?</h3>

<p>I assume you should be familiar with programming with Unity, that‚Äôs all. <em>:)</em></p>

<p>I will explain everything you need to know in the tutorial and you will see it is so easy, in fact, to create the visual effects and the only boundary to use the rest is your imagination.</p>

<p>If you are more than curious with the content, here‚Äôs a list of quickie keywords:</p>

<ul>
  <li><strong>ray tracing</strong></li>
  <li><strong>compute shader</strong></li>
  <li><strong>fresnel effect</strong></li>
</ul>

<p>Don‚Äôt be afraid of the terms if you don‚Äôt know about them! They are really, really simple to understand. And in fact you don‚Äôt need to understand everything about them.</p>

<h3 id="cut-the-crapslets-get-started">Cut the craps‚Ä¶Let‚Äôs get started!</h3>

<p>There is a premade Unity package to get you start. <strong><a href="./assets/marble-shader-starter.unitypackage">Download it here</a>.</strong></p>

<hr />

<h3 id="now-it-renders">Now it Renders‚Ä¶</h3>

<p>If you haven‚Äôt downloaded the Unity package, you must didn‚Äôt read my tutorial carefully enough. :( Don‚Äôt worry! I do that sometimes, too! The link is above, with text bolded, go download it, and open it in Unity. I reminded you again because, I love you.</p>

<p>Now, the project is setup pretty simple and should get you started. We have a scene with a camera, a C# script named <code class="highlighter-rouge">RayTrace.cs</code> attached to the camera, and a compute shader named <code class="highlighter-rouge">RayTrace.compute</code> attached to the C# script. If you click on ‚ÄúPlay‚Äù button you should be able to see it does work - a pattern is rendered from compute shader to screen.</p>

<p>The C# script does one thing: it links the compute shader to Unity <code class="highlighter-rouge">MonoBehaviour</code> lifecycle and sends the output to screen. And the compute shader generates a pattern. Later we will send some data from Unity to shader and get it back, the data will be <em>computed</em> and returned and that‚Äôs why we call the shader as a compute API because it does more than graphics rendering!</p>

<blockquote>
  <p><strong>Tip 0</strong>. Go on, click ‚ÄúPlay‚Äù and see what happens :)</p>
</blockquote>

<blockquote>
  <p><strong>Tip 1</strong>. In case you are very interested in compute shader I have also made a procgen grass shader, the wind swing movement of grass mesh vertices is computed inside shader and sent back to Unity. It‚Äôs open sourced! I released it on <a href="https://github.com/KHN190/UnityGrassShader">GitHub</a>.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/KHN190/UnityGrassShader/master/img/grassSwing.gif" alt="" /></p>

<p><em>* Above is the result of my grass shader, all vertex movement is computed using a compute shader.</em></p>

<p>Let‚Äôs read some code:</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// RayTrace.cs</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">RayTrace</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">RenderTexture</span> <span class="n">target</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">ComputeShader</span> <span class="n">shader</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnRenderImage</span><span class="p">(</span><span class="n">RenderTexture</span> <span class="n">source</span><span class="p">,</span> <span class="n">RenderTexture</span> <span class="n">destination</span><span class="p">)</span>
    <span class="p">{</span>
    	<span class="c1">// Initiate Screen target, and dispatch compute shader</span>
        <span class="nf">Render</span><span class="p">(</span><span class="n">destination</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">target</code> is our output, screen. The <code class="highlighter-rouge">shader</code> is where output pixels are calculated. The <code class="highlighter-rouge">Render</code> function is our entry to shader initialization, which does a few more things:</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// RayTrace.cs</span>
<span class="k">private</span> <span class="k">void</span> <span class="nf">Render</span><span class="p">(</span><span class="n">RenderTexture</span> <span class="n">destination</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Make sure we have a current render target</span>
    <span class="nf">InitRenderTexture</span><span class="p">();</span>

    <span class="c1">// Set the target and dispatch the compute shader</span>
    <span class="n">shader</span><span class="p">.</span><span class="nf">SetTexture</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="s">"Result"</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">threadGroupsX</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">CeilToInt</span><span class="p">(</span><span class="n">Screen</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">8.0f</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">threadGroupsY</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">CeilToInt</span><span class="p">(</span><span class="n">Screen</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">8.0f</span><span class="p">);</span>
    <span class="n">shader</span><span class="p">.</span><span class="nf">Dispatch</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">threadGroupsX</span><span class="p">,</span> <span class="n">threadGroupsY</span><span class="p">,</span> <span class="m">1</span><span class="p">);</span>

    <span class="c1">// Blit the result texture to the screen</span>
    <span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">destination</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">void</span> <span class="nf">InitRenderTexture</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="p">==</span> <span class="k">null</span> <span class="p">||</span> <span class="n">target</span><span class="p">.</span><span class="n">width</span> <span class="p">!=</span> <span class="n">Screen</span><span class="p">.</span><span class="n">width</span> <span class="p">||</span> <span class="n">target</span><span class="p">.</span><span class="n">height</span> <span class="p">!=</span> <span class="n">Screen</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">RenderTexture</span> <span class="n">init</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">RenderTexture</span><span class="p">(</span><span class="n">Screen</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">Screen</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span>
            <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">ARGBFloat</span><span class="p">,</span> <span class="n">RenderTextureReadWrite</span><span class="p">.</span><span class="n">Linear</span><span class="p">);</span>
        <span class="n">init</span><span class="p">.</span><span class="n">enableRandomWrite</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="n">init</span><span class="p">.</span><span class="nf">Create</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
            <span class="n">target</span><span class="p">.</span><span class="nf">Release</span><span class="p">();</span>
        <span class="n">target</span> <span class="p">=</span> <span class="n">init</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The line <code class="highlighter-rouge">shader.Dispatch</code> starts our shader, and <code class="highlighter-rouge">Graphics.Blit</code> gets its output to screen. We will leave them like it is once we setup, and now it should work. So we can move to the shader:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma kernel CSMain
</span>
<span class="n">RWTexture2D</span><span class="o">&lt;</span><span class="n">float4</span><span class="o">&gt;</span> <span class="n">Result</span><span class="p">;</span>

<span class="c1">// CSMain stands for "Compute Shader Main Program" but the name is arbitrary</span>
<span class="p">[</span><span class="n">numthreads</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
<span class="kt">void</span> <span class="nf">CSMain</span> <span class="p">(</span><span class="n">uint3</span> <span class="n">id</span> <span class="o">:</span> <span class="n">SV_DispatchThreadID</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Result</span><span class="p">[</span><span class="n">id</span><span class="p">.</span><span class="n">xy</span><span class="p">]</span> <span class="o">=</span> <span class="n">float4</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">id</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">)</span><span class="o">/</span><span class="mi">15</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">y</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">)</span><span class="o">/</span><span class="mi">15</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Each compute shader has a main program, in this case, it is <code class="highlighter-rouge">CSMain</code>. The <code class="highlighter-rouge">numthreads</code> defines the way you use GPU cores, for more advanced fine-tuning purposes. In this tutorial use the number here is fine.</p>

<p>Adn we have the variable of our screen data defined in <code class="highlighter-rouge">RWTexture2D&lt;float4&gt; Result</code>. That‚Äôs how the last line <code class="highlighter-rouge">Result[id.xy] = color</code> is possible to change our screen. If you want to ever change the last line to see how it works, feel free to do it so! e.g. change it to:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Result</span><span class="p">[</span><span class="n">id</span><span class="p">.</span><span class="n">xy</span><span class="p">]</span> <span class="o">=</span> <span class="n">float4</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// green</span>
</code></pre></div></div>

<p>See? Do you have any idea why it is <code class="highlighter-rouge">float4</code> now? Because it stands for 4 channels of colors: red, green, blue, and alpha (RGBA). And that is how shaders work, really. We are assiging colors to each pixel on <code class="highlighter-rouge">id.xy</code>, and we blend colors to get what we desire. Each pixel is binded to its position on screen, so we will also do a little magic using some math. :)</p>

<hr />

<h3 id="my-camera-can-shoot-a-ray">My Camera Can Shoot a Ray!</h3>

<p>OK. What now? For a <a href="https://en.wikipedia.org/wiki/Demoscene">demo scene</a> the first thing I want is a plane which can accept lights and shadows. The second part is the background skybox. And the rest is our ‚Äúreal‚Äù marble shader on a sphere.</p>

<p>And we are going to test the colors on each pixel, the test is made possible with a ray shot from our main camera, and the ray tells me the closest object to camera on that pixel so we can decide the color accordingly.</p>

<blockquote>
  <p>Since we are going to only have a plane, a skybox, and a sphere, the test is dead simple - we will be testing intersection with all objects, seeing if anything is the closest.</p>
</blockquote>

<p>The <a href="https://en.wikipedia.org/wiki/Ray_tracing_(graphics)">ray</a> is also physically simulated, similar to what light in nature will do - I mean simulated, not exactly the same. After all, we are building graphics and sometimes it is necessary to bend the physical rules for better looking / performance. The reason we are doing it using ray tracing is it gives a photorealistic looking and it is intuitive in this case - we want refraction, right? Then simulate the real physical process.</p>

<p>In the compute shader add the following code to the head, before <code class="highlighter-rouge">CSMain</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">struct</span> <span class="n">Ray</span>
<span class="p">{</span>
    <span class="n">float3</span> <span class="n">origin</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">direction</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">energy</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">struct</span> <span class="n">RayHit</span>
<span class="p">{</span>
    <span class="n">float3</span> <span class="n">position</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">distance</span><span class="p">;</span>
    <span class="n">float3</span> <span class="n">normal</span><span class="p">;</span>
    <span class="n">uint</span> <span class="n">object</span><span class="p">;</span>
<span class="p">};</span>
</code></pre></div></div>

<p>And we have the function to create a ray and the hit info, add them after the structs definition, but before <code class="highlighter-rouge">CSMain</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Ray</span> <span class="nf">CreateRay</span><span class="p">(</span><span class="n">float3</span> <span class="n">origin</span><span class="p">,</span> <span class="n">float3</span> <span class="n">direction</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Ray</span> <span class="n">ray</span><span class="p">;</span>
    <span class="n">ray</span><span class="p">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">origin</span><span class="p">;</span>
    <span class="n">ray</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">direction</span><span class="p">;</span>
    <span class="n">ray</span><span class="p">.</span><span class="n">energy</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span><span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">ray</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">RayHit</span> <span class="nf">CreateRayHit</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">RayHit</span> <span class="n">hit</span><span class="p">;</span>
    <span class="n">hit</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">);</span>
    <span class="n">hit</span><span class="p">.</span><span class="n">distance</span> <span class="o">=</span> <span class="mi">1</span><span class="p">.</span><span class="err">#</span><span class="n">INF</span><span class="p">;</span>
    <span class="n">hit</span><span class="p">.</span><span class="n">normal</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">);</span>
    <span class="n">hit</span><span class="p">.</span><span class="n">object</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">hit</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Everything here is self explanatory, only the <code class="highlighter-rouge">unit object</code> is reserved for tagging the objects - I want to tell if it is hit on a plane, skybox, or a sphere. By default, it is <code class="highlighter-rouge">0</code> - denotes the skybox.</p>

<p>Now the only problem left for this section is, how do we create a ray from camera? Since we are going to use Unity‚Äôs camera, we need to transfer that information from Unity to GPU. So in the compute shader, we define it:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// after the line `#pragma kernel Main`</span>

<span class="c1">// Input</span>
<span class="n">float4x4</span> <span class="n">_CameraToWorld</span><span class="p">;</span>
<span class="n">float4x4</span> <span class="n">_CameraInverseProjection</span><span class="p">;</span>

<span class="c1">// Output</span>
<span class="n">RWTexture2D</span><span class="o">&lt;</span><span class="n">float4</span><span class="o">&gt;</span> <span class="n">Result</span><span class="p">;</span>
</code></pre></div></div>

<p>And after the <code class="highlighter-rouge">CreateRayHit</code> function we can project everything to camera space:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Ray</span> <span class="nf">CreateCameraRay</span><span class="p">(</span><span class="n">float2</span> <span class="n">uv</span><span class="p">,</span> <span class="n">float4x4</span> <span class="n">camToWorld</span><span class="p">,</span> <span class="n">float4x4</span> <span class="n">camInvProj</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Transform the camera origin to world space</span>
    <span class="n">float3</span> <span class="n">origin</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">camToWorld</span><span class="p">,</span> <span class="n">float4</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>
    <span class="c1">// Invert the perspective projection of the view-space position</span>
    <span class="n">float3</span> <span class="n">direction</span> <span class="o">=</span> <span class="n">mul</span><span class="p">(</span><span class="n">camInvProj</span><span class="p">,</span> <span class="n">float4</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">)).</span><span class="n">xyz</span><span class="p">;</span>
    <span class="c1">// Transform the direction from camera to world space</span>
    <span class="n">direction</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">mul</span><span class="p">(</span><span class="n">camToWorld</span><span class="p">,</span> <span class="n">float4</span><span class="p">(</span><span class="n">direction</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">)).</span><span class="n">xyz</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">CreateRay</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">direction</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>In the <code class="highlighter-rouge">CSMain</code> we can create the ray for each pixel then:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="n">numthreads</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
<span class="kt">void</span> <span class="nf">CSMain</span> <span class="p">(</span><span class="n">uint3</span> <span class="n">id</span> <span class="o">:</span> <span class="n">SV_DispatchThreadID</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Get the dimensions of the RenderTexture</span>
    <span class="n">uint</span> <span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">;</span>
    <span class="n">Result</span><span class="p">.</span><span class="n">GetDimensions</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">);</span>
    <span class="c1">// Transform pixel to [-1,1] range</span>
    <span class="n">float2</span> <span class="n">uv</span> <span class="o">=</span> <span class="n">float2</span><span class="p">((</span><span class="n">id</span><span class="p">.</span><span class="n">xy</span> <span class="o">+</span> <span class="mi">0</span><span class="p">.</span><span class="mi">5</span><span class="p">)</span> <span class="o">/</span> <span class="n">float2</span><span class="p">(</span><span class="n">width</span><span class="p">,</span> <span class="n">height</span><span class="p">)</span> <span class="o">*</span> <span class="mi">2</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span> <span class="o">-</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="n">f</span><span class="p">);</span>
    <span class="c1">// Create a ray</span>
    <span class="n">Ray</span> <span class="n">ray</span> <span class="o">=</span> <span class="n">CreateCameraRay</span><span class="p">(</span><span class="n">uv</span><span class="p">,</span> <span class="n">_CameraToWorld</span><span class="p">,</span> <span class="n">_CameraInverseProjection</span><span class="p">);</span>

    <span class="n">float3</span> <span class="n">color</span> <span class="o">=</span> <span class="n">ray</span><span class="p">.</span><span class="n">origin</span><span class="p">;</span>
    <span class="n">Result</span><span class="p">[</span><span class="n">id</span><span class="p">.</span><span class="n">xy</span><span class="p">]</span> <span class="o">=</span> <span class="n">float4</span><span class="p">(</span><span class="n">color</span><span class="p">.</span><span class="n">r</span><span class="p">,</span> <span class="n">color</span><span class="p">.</span><span class="n">g</span><span class="p">,</span> <span class="n">color</span><span class="p">.</span><span class="n">b</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The camera settings are predefined in Unity, thanks :)</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// after shader.SetTexture(0, "Result", target);</span>
<span class="n">shader</span><span class="p">.</span><span class="nf">SetMatrix</span><span class="p">(</span><span class="s">"_CameraToWorld"</span><span class="p">,</span> <span class="n">Camera</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">cameraToWorldMatrix</span><span class="p">);</span>
<span class="n">shader</span><span class="p">.</span><span class="nf">SetMatrix</span><span class="p">(</span><span class="s">"_CameraInverseProjection"</span><span class="p">,</span> <span class="n">Camera</span><span class="p">.</span><span class="n">main</span><span class="p">.</span><span class="n">projectionMatrix</span><span class="p">.</span><span class="n">inverse</span><span class="p">);</span>
</code></pre></div></div>

<p>Finally, if we want to verify everything works, click ‚ÄúPlay‚Äù! But before that, think for a while, what you will be seeing? Remember, the line that defines our pixel is <code class="highlighter-rouge">float3 color = ray.origin;</code> if you haven‚Äôt noticed, is it the same result as you expected? Why? ;)</p>

<blockquote>
  <p>Try drag the camera in Unity Editor along XYZ axis, now what happens??</p>
</blockquote>

<hr />

<h3 id="the-ray-shall-be-traced">The Ray Shall be Traced</h3>

<p><img src="./assets/img/blank.png" alt="" /></p>

<p><em>The ray‚Äôs origin is transformed to RGB on each pixel, the color varies when camera moves.</em></p>

<p>For now‚Ä¶we have successfully created a ray for each pixel, but we don‚Äôt test any object for the rays, so we don‚Äôt know what exactly should be output to the pixel yet. We are doing it now.</p>

<p>Add the lines after <code class="highlighter-rouge">CreateCameraRay</code> but before <code class="highlighter-rouge">CSMain</code>:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// trace a ray</span>
<span class="n">RayHit</span> <span class="nf">Trace</span><span class="p">(</span><span class="n">Ray</span> <span class="n">ray</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">RayHit</span> <span class="n">bestHit</span> <span class="o">=</span> <span class="n">CreateRayHit</span><span class="p">();</span>
    <span class="c1">// intersect with plane</span>
    <span class="n">IntersectGroundPlane</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="n">bestHit</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">bestHit</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// output color</span>
<span class="n">float4</span> <span class="nf">Shade</span><span class="p">(</span><span class="n">inout</span> <span class="n">Ray</span> <span class="n">ray</span><span class="p">,</span> <span class="n">RayHit</span> <span class="n">hit</span><span class="p">)</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hit</span><span class="p">.</span><span class="n">object</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="c1">// hit ground</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">hit</span><span class="p">.</span><span class="n">object</span> <span class="o">==</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="mi">1</span><span class="p">)</span>
            <span class="k">return</span> <span class="n">Reflective</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="n">hit</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// If hit nothing</span>
    <span class="k">return</span> <span class="n">Background</span><span class="p">(</span><span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>We have introduced 3 new functions:</p>

<ul>
  <li><code class="highlighter-rouge">IntersectGroundPlane</code> which tests if the ray from camera hits a plane</li>
  <li><code class="highlighter-rouge">Reflective</code> which defines how a light looks like on a metal-like surface</li>
  <li><code class="highlighter-rouge">Background</code> which defines how the skybox looks like</li>
</ul>

<p>And because for shaders you can only use a function after you define it, we need some new definitions. The descriptive function for plane intersection is simple, we use object number <code class="highlighter-rouge">1</code> for plane:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">void</span> <span class="nf">IntersectGroundPlane</span><span class="p">(</span><span class="n">Ray</span> <span class="n">ray</span><span class="p">,</span> <span class="n">inout</span> <span class="n">RayHit</span> <span class="n">bestHit</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Calculate distance along the ray where the ground plane is intersected</span>
    <span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="o">-</span><span class="n">ray</span><span class="p">.</span><span class="n">origin</span><span class="p">.</span><span class="n">y</span> <span class="o">/</span> <span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">.</span><span class="n">y</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">bestHit</span><span class="p">.</span><span class="n">distance</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">bestHit</span><span class="p">.</span><span class="n">distance</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
        <span class="n">bestHit</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">ray</span><span class="p">.</span><span class="n">origin</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">;</span>
        <span class="n">bestHit</span><span class="p">.</span><span class="n">normal</span> <span class="o">=</span> <span class="n">float3</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
        <span class="n">bestHit</span><span class="p">.</span><span class="n">object</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<blockquote>
  <p>It is totally possible to create other objects like this! Like, torus. <a href="https://www.shadertoy.com/view/tltGzj">Shadertoy.com</a> has many interesting examples and you should definetely have a look.</p>
</blockquote>

<p>We also need other two for metal-like materials and for skybox:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">float4</span> <span class="nf">Reflective</span><span class="p">(</span><span class="n">inout</span> <span class="n">Ray</span> <span class="n">ray</span><span class="p">,</span> <span class="n">RayHit</span> <span class="n">hit</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// slightly step aside from the origin </span>
    <span class="c1">// so it doesn't get recalculated at the same position</span>
    <span class="n">ray</span><span class="p">.</span><span class="n">origin</span> <span class="o">=</span> <span class="n">hit</span><span class="p">.</span><span class="n">position</span> <span class="o">+</span> <span class="n">hit</span><span class="p">.</span><span class="n">normal</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mo">001</span><span class="p">;</span>
    <span class="c1">// ray is reflected and direction changes</span>
    <span class="n">ray</span><span class="p">.</span><span class="n">direction</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">reflect</span><span class="p">(</span><span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">,</span> <span class="n">hit</span><span class="p">.</span><span class="n">normal</span><span class="p">));</span>
    <span class="c1">// energy decay after reflection</span>
    <span class="n">ray</span><span class="p">.</span><span class="n">energy</span> <span class="o">=</span>  <span class="n">ray</span><span class="p">.</span><span class="n">energy</span> <span class="o">*</span> <span class="mi">0</span><span class="p">.</span><span class="mi">8</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">float4</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">float4</span> <span class="nf">Background</span><span class="p">(</span><span class="n">float3</span> <span class="n">vec</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">//return float4(0.5, 0.5, 0.5, 1.0);</span>
    <span class="k">return</span> <span class="n">float4</span><span class="p">(</span><span class="n">vec</span><span class="p">.</span><span class="n">x</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="n">vec</span><span class="p">.</span><span class="n">z</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>And we need to change <code class="highlighter-rouge">CSMain</code> to output our desired colors. Delete the lines about colors, replace them with:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// in CSMain, after Ray ray = CreateCameraRay(...)</span>

<span class="c1">// by default it is dark black</span>
<span class="n">float4</span> <span class="n">color</span> <span class="o">=</span> <span class="n">float4</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="c1">// Bounce 8 times</span>
<span class="k">for</span> <span class="p">(</span><span class="n">uint</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">8</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">RayHit</span> <span class="n">hit</span> <span class="o">=</span> <span class="n">Trace</span><span class="p">(</span><span class="n">ray</span><span class="p">);</span>
    <span class="n">float4</span> <span class="n">output</span> <span class="o">=</span> <span class="n">Shade</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="n">hit</span><span class="p">);</span>
    <span class="c1">// hit on object, so color is changed</span>
    <span class="n">color</span><span class="p">.</span><span class="n">rgb</span> <span class="o">+=</span> <span class="n">ray</span><span class="p">.</span><span class="n">energy</span> <span class="o">*</span> <span class="n">output</span><span class="p">.</span><span class="n">rgb</span> <span class="o">*</span> <span class="n">output</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>
    <span class="n">color</span><span class="p">.</span><span class="n">a</span> <span class="o">=</span> <span class="n">output</span><span class="p">.</span><span class="n">a</span><span class="p">;</span>

    <span class="c1">// hit skybox</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hit</span><span class="p">.</span><span class="n">object</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="p">{</span>
    	<span class="c1">// reset energy</span>
        <span class="n">ray</span><span class="p">.</span><span class="n">energy</span> <span class="o">=</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">;</span>
        <span class="c1">// stop bouncing</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
<span class="n">Result</span><span class="p">[</span><span class="n">id</span><span class="p">.</span><span class="n">xy</span><span class="p">]</span> <span class="o">=</span> <span class="n">color</span><span class="p">;</span>
</code></pre></div></div>

<p>Click ‚ÄúPlay‚Äù!</p>

<p><img src="./assets/img/hit_normal.png" alt="" /></p>

<p>The line <code class="highlighter-rouge">ray.direction</code> is where ‚Äúmagic‚Äù lays. Since compute shader uses <a href="https://en.wikipedia.org/wiki/High-Level_Shading_Language">HLSL</a> language, it provided us a very handy function <code class="highlighter-rouge">reflect</code> to calculate light reflection. Light direction is changed, and that‚Äôs all to get physically simulated lights.</p>

<hr />

<h3 id="create-a-sphere">Create a Sphere</h3>

<p>Now we are creating the sphere in the center of our screen. Remeber how we test intersection with plane above? Sphere intersection is much similar. Define our new sphere data, and add lines after plane intersection function:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// new struct, add after Ray and RayHit</span>
<span class="k">struct</span> <span class="n">Sphere</span>
<span class="p">{</span>
    <span class="n">float3</span> <span class="n">position</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">radius</span><span class="p">;</span>
<span class="p">};</span>

<span class="c1">// new intersection function</span>
<span class="kt">void</span> <span class="nf">IntersectSphere</span><span class="p">(</span><span class="n">Ray</span> <span class="n">ray</span><span class="p">,</span> <span class="n">inout</span> <span class="n">RayHit</span> <span class="n">bestHit</span><span class="p">,</span> <span class="n">Sphere</span> <span class="n">sphere</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Calculate distance along the ray where the sphere is intersected</span>
    <span class="n">float3</span> <span class="n">d</span> <span class="o">=</span> <span class="n">ray</span><span class="p">.</span><span class="n">origin</span> <span class="o">-</span> <span class="n">sphere</span><span class="p">.</span><span class="n">position</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">p1</span> <span class="o">=</span> <span class="o">-</span><span class="n">dot</span><span class="p">(</span><span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">,</span> <span class="n">d</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">p2sqr</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">*</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">dot</span><span class="p">(</span><span class="n">d</span><span class="p">,</span> <span class="n">d</span><span class="p">)</span> <span class="o">+</span> <span class="n">sphere</span><span class="p">.</span><span class="n">radius</span> <span class="o">*</span> <span class="n">sphere</span><span class="p">.</span><span class="n">radius</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">p2sqr</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">return</span><span class="p">;</span>
    <span class="kt">float</span> <span class="n">p2</span> <span class="o">=</span> <span class="n">sqrt</span><span class="p">(</span><span class="n">p2sqr</span><span class="p">);</span>
    <span class="kt">float</span> <span class="n">t</span> <span class="o">=</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">p2</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">?</span> <span class="n">p1</span> <span class="o">-</span> <span class="n">p2</span> <span class="o">:</span> <span class="n">p1</span> <span class="o">+</span> <span class="n">p2</span><span class="p">;</span>
    <span class="c1">// find closest hit</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">t</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">t</span> <span class="o">&lt;</span> <span class="n">bestHit</span><span class="p">.</span><span class="n">distance</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">bestHit</span><span class="p">.</span><span class="n">distance</span> <span class="o">=</span> <span class="n">t</span><span class="p">;</span>
        <span class="n">bestHit</span><span class="p">.</span><span class="n">position</span> <span class="o">=</span> <span class="n">ray</span><span class="p">.</span><span class="n">origin</span> <span class="o">+</span> <span class="n">t</span> <span class="o">*</span> <span class="n">ray</span><span class="p">.</span><span class="n">direction</span><span class="p">;</span>
        <span class="n">bestHit</span><span class="p">.</span><span class="n">normal</span> <span class="o">=</span> <span class="n">normalize</span><span class="p">(</span><span class="n">bestHit</span><span class="p">.</span><span class="n">position</span> <span class="o">-</span> <span class="n">sphere</span><span class="p">.</span><span class="n">position</span><span class="p">);</span>
        <span class="n">bestHit</span><span class="p">.</span><span class="n">object</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// in void Shade(), we are gonna check the sphere as well</span>
<span class="k">if</span> <span class="p">(</span><span class="n">hit</span><span class="p">.</span><span class="n">object</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// hit ground</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hit</span><span class="p">.</span><span class="n">object</span> <span class="o">==</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="mi">1</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Reflective</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="n">hit</span><span class="p">);</span>

    <span class="c1">// hit sphere</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">hit</span><span class="p">.</span><span class="n">object</span> <span class="o">==</span> <span class="p">(</span><span class="n">uint</span><span class="p">)</span><span class="mi">2</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">Reflective</span><span class="p">(</span><span class="n">ray</span><span class="p">,</span> <span class="n">hit</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Now everything for sphere shading / intersection test is ready but we <em>don‚Äôt have a sphere</em> yet. It is, possible that to create spheres in Unity and pass the data to GPU, which is what I have done in the <a href="https://github.com/KHN190/the-biography">final project</a>. However, for simplicity let‚Äôs create the sphere in shader by some hardcoding.</p>

<p><a href="./">back</a></p>
:ET