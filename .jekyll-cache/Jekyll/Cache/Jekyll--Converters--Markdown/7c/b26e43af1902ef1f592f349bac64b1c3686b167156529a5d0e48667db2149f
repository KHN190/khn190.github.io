I"ÿ8<h2 id="lets-create-a-marble-shader-in-unity">Let‚Äôs Create a Marble Shader in Unity!</h2>

<p>Back sometime, when I wandered in the cyber space I found a post about <a href="https://80.lv/articles/building-intricate-ice-shaders/">creating intricate ice in Unity</a>, and I immediately fell in love with the visual patterns. There is an incredibly beautiful image for you to have a feel:</p>

<p><img src="./assets/img/ice_shader.png" alt="" /></p>

<p>However when I bought the asset to see how it works, I was slightly unsatisfied because most of the patterns are baked in textures. The ices are not actually usable for arbitrary objects except for plane. And they are not transparent. I clearly want a toy with similar breath but has the following traits:</p>

<ol>
  <li>it can reflect lights</li>
  <li>it can refract other objects through it</li>
  <li>it has to be transparent (by axiom 2, right?)</li>
</ol>

<p>And after some research, I had this as my result - which is also the same you will have after the tutorial:</p>

<p><img src="./assets/img/marble.gif" alt="" /></p>

<h3 id="what-do-i-need-to-know-in-advance">What do I need to know in advance?</h3>

<p>I assume you should be familiar with programming with Unity, that‚Äôs all. <em>:)</em></p>

<p>I will explain everything you need to know in the tutorial and you will see it is so easy, in fact, to create the visual effects and the only boundary to use the rest is your imagination.</p>

<p>If you are more than curious with the content, here‚Äôs a list of quickie keywords:</p>

<ul>
  <li><strong>ray tracing</strong></li>
  <li><strong>compute shader</strong></li>
  <li><strong>fresnel effect</strong></li>
</ul>

<p>Don‚Äôt be afraid of the terms if you don‚Äôt know about them! They are really, really simple to understand. And in fact you don‚Äôt need to understand everything about them.</p>

<h3 id="cut-the-crapslets-get-started">Cut the craps‚Ä¶Let‚Äôs get started!</h3>

<p>There is a premade Unity package to get you start. <strong><a href="./assets/marble-shader-starter.unitypackage">Download it here</a>.</strong></p>

<hr />

<h3 id="now-it-renders">Now it Renders‚Ä¶</h3>

<p>If you haven‚Äôt downloaded the Unity package, you must didn‚Äôt read my tutorial carefully enough. :( Don‚Äôt worry! I do that sometimes, too! The link is above, with text bolded, go download it, and open it in Unity. I reminded you again because, I love you.</p>

<p>Now, the project is setup pretty simple and should get you started. We have a scene with a camera, a C# script named <code class="highlighter-rouge">RayTrace.cs</code> attached to the camera, and a compute shader named <code class="highlighter-rouge">RayTrace.compute</code> attached to the C# script. If you click on ‚ÄúPlay‚Äù button you should be able to see it does work - a pattern is rendered from compute shader to screen.</p>

<p>The C# script does one thing: it links the compute shader to Unity <code class="highlighter-rouge">MonoBehaviour</code> lifecycle and sends the output to screen. And the compute shader generates a pattern. Later we will send some data from Unity to shader and get it back, the data will be <em>computed</em> and returned and that‚Äôs why we call the shader as a compute API because it does more than graphics rendering!</p>

<blockquote>
  <p><strong>Tip 0</strong>. Go on, click ‚ÄúPlay‚Äù and see what happens :)</p>
</blockquote>

<blockquote>
  <p><strong>Tip 1</strong>. In case you are very interested in compute shader I have also made a procgen grass shader, the wind swing movement of grass mesh vertices is computed inside shader and sent back to Unity. It‚Äôs open sourced! I released it on <a href="https://github.com/KHN190/UnityGrassShader">GitHub</a>.</p>
</blockquote>

<p><img src="https://raw.githubusercontent.com/KHN190/UnityGrassShader/master/img/grassSwing.gif" alt="" /></p>

<p><em>* Above is the result of my grass shader, all vertex movement is computed using a compute shader.</em></p>

<p>Let‚Äôs read some code:</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// RayTrace.cs</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">RayTrace</span> <span class="p">:</span> <span class="n">MonoBehaviour</span>
<span class="p">{</span>
    <span class="k">private</span> <span class="n">RenderTexture</span> <span class="n">target</span><span class="p">;</span>
    <span class="k">public</span> <span class="n">ComputeShader</span> <span class="n">shader</span><span class="p">;</span>

    <span class="k">private</span> <span class="k">void</span> <span class="nf">OnRenderImage</span><span class="p">(</span><span class="n">RenderTexture</span> <span class="n">source</span><span class="p">,</span> <span class="n">RenderTexture</span> <span class="n">destination</span><span class="p">)</span>
    <span class="p">{</span>
    	<span class="c1">// Initiate Screen target, and dispatch compute shader</span>
        <span class="nf">Render</span><span class="p">(</span><span class="n">destination</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The <code class="highlighter-rouge">target</code> is our output, screen. The <code class="highlighter-rouge">shader</code> is where output pixels are calculated. The <code class="highlighter-rouge">Render</code> function is our entry to shader initialization, which does a few more things:</p>

<div class="language-cs highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// RayTrace.cs</span>
<span class="k">private</span> <span class="k">void</span> <span class="nf">Render</span><span class="p">(</span><span class="n">RenderTexture</span> <span class="n">destination</span><span class="p">)</span>
<span class="p">{</span>
    <span class="c1">// Make sure we have a current render target</span>
    <span class="nf">InitRenderTexture</span><span class="p">();</span>

    <span class="c1">// Set the target and dispatch the compute shader</span>
    <span class="n">shader</span><span class="p">.</span><span class="nf">SetTexture</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="s">"Result"</span><span class="p">,</span> <span class="n">target</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">threadGroupsX</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">CeilToInt</span><span class="p">(</span><span class="n">Screen</span><span class="p">.</span><span class="n">width</span> <span class="p">/</span> <span class="m">8.0f</span><span class="p">);</span>
    <span class="kt">int</span> <span class="n">threadGroupsY</span> <span class="p">=</span> <span class="n">Mathf</span><span class="p">.</span><span class="nf">CeilToInt</span><span class="p">(</span><span class="n">Screen</span><span class="p">.</span><span class="n">height</span> <span class="p">/</span> <span class="m">8.0f</span><span class="p">);</span>
    <span class="n">shader</span><span class="p">.</span><span class="nf">Dispatch</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="n">threadGroupsX</span><span class="p">,</span> <span class="n">threadGroupsY</span><span class="p">,</span> <span class="m">1</span><span class="p">);</span>

    <span class="c1">// Blit the result texture to the screen</span>
    <span class="n">Graphics</span><span class="p">.</span><span class="nf">Blit</span><span class="p">(</span><span class="n">target</span><span class="p">,</span> <span class="n">destination</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">private</span> <span class="k">void</span> <span class="nf">InitRenderTexture</span><span class="p">()</span>
<span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="p">==</span> <span class="k">null</span> <span class="p">||</span> <span class="n">target</span><span class="p">.</span><span class="n">width</span> <span class="p">!=</span> <span class="n">Screen</span><span class="p">.</span><span class="n">width</span> <span class="p">||</span> <span class="n">target</span><span class="p">.</span><span class="n">height</span> <span class="p">!=</span> <span class="n">Screen</span><span class="p">.</span><span class="n">height</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">RenderTexture</span> <span class="n">init</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">RenderTexture</span><span class="p">(</span><span class="n">Screen</span><span class="p">.</span><span class="n">width</span><span class="p">,</span> <span class="n">Screen</span><span class="p">.</span><span class="n">height</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span>
            <span class="n">RenderTextureFormat</span><span class="p">.</span><span class="n">ARGBFloat</span><span class="p">,</span> <span class="n">RenderTextureReadWrite</span><span class="p">.</span><span class="n">Linear</span><span class="p">);</span>
        <span class="n">init</span><span class="p">.</span><span class="n">enableRandomWrite</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="n">init</span><span class="p">.</span><span class="nf">Create</span><span class="p">();</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">target</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
            <span class="n">target</span><span class="p">.</span><span class="nf">Release</span><span class="p">();</span>
        <span class="n">target</span> <span class="p">=</span> <span class="n">init</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>The line <code class="highlighter-rouge">shader.Dispatch</code> starts our shader, and <code class="highlighter-rouge">Graphics.Blit</code> gets its output to screen. We will leave them like it is once we setup, and now it should work. So we can move to the shader:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="cp">#pragma kernel CSMain
</span>
<span class="n">RWTexture2D</span><span class="o">&lt;</span><span class="n">float4</span><span class="o">&gt;</span> <span class="n">Result</span><span class="p">;</span>

<span class="c1">// CSMain stands for "Compute Shader Main Program" but the name is arbitrary</span>
<span class="p">[</span><span class="n">numthreads</span><span class="p">(</span><span class="mi">8</span><span class="p">,</span><span class="mi">8</span><span class="p">,</span><span class="mi">1</span><span class="p">)]</span>
<span class="kt">void</span> <span class="nf">CSMain</span> <span class="p">(</span><span class="n">uint3</span> <span class="n">id</span> <span class="o">:</span> <span class="n">SV_DispatchThreadID</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Result</span><span class="p">[</span><span class="n">id</span><span class="p">.</span><span class="n">xy</span><span class="p">]</span> <span class="o">=</span> <span class="n">float4</span><span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;</span> <span class="n">id</span><span class="p">.</span><span class="n">y</span><span class="p">,</span> <span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">x</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">)</span><span class="o">/</span><span class="mi">15</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">id</span><span class="p">.</span><span class="n">y</span> <span class="o">&amp;</span> <span class="mi">15</span><span class="p">)</span><span class="o">/</span><span class="mi">15</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>Each compute shader has a main program, in this case, it is <code class="highlighter-rouge">CSMain</code>. The <code class="highlighter-rouge">numthreads</code> defines the way you use GPU cores, for more advanced fine-tuning purposes. In this tutorial use the number here is fine.</p>

<p>Adn we have the variable of our screen data defined in <code class="highlighter-rouge">RWTexture2D&lt;float4&gt; Result</code>. That‚Äôs how the last line <code class="highlighter-rouge">Result[id.xy] = color</code> is possible to change our screen. If you want to ever change the last line to see how it works, feel free to do it so! e.g. change it to:</p>

<div class="language-c highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Result</span><span class="p">[</span><span class="n">id</span><span class="p">.</span><span class="n">xy</span><span class="p">]</span> <span class="o">=</span> <span class="n">float4</span><span class="p">(</span><span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">.</span><span class="mi">0</span><span class="p">);</span> <span class="c1">// green</span>
</code></pre></div></div>

<p>See? Do you have any idea why it is <code class="highlighter-rouge">float4</code> now? Because it stands for 4 channels of colors: red, green, blue, and alpha (RGBA). And that is how shaders work, really. We are assiging colors to each pixel on <code class="highlighter-rouge">id.xy</code>, and we blend colors to get what we desire. Each pixel is binded to its position on screen, so we will also do a little magic using some math. :)</p>

<h3 id="create-a-plane">Create a Plane</h3>

<p>OK. What now? For a <a href="https://en.wikipedia.org/wiki/Demoscene">demo scene</a> it is important to have an object as reference, so the first thing I want is a plane which can accept lights and shadows.</p>

<p><a href="./">back</a></p>
:ET